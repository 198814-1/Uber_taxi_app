// Generated by CoffeeScript 1.7.1

/*
This docstring documents JugglingCrud. It can include *Markdown* syntax,
which will be converted to html.
 */

(function() {
  var BaseCrud, JugglingCrud, async,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  async = require('async');

  BaseCrud = require('../crud/crud-base').BaseCrud;

  JugglingCrud = (function(_super) {
    __extends(JugglingCrud, _super);

    function JugglingCrud() {
      return JugglingCrud.__super__.constructor.apply(this, arguments);
    }

    JugglingCrud.prototype.read = function(ModelClazz, aFilter, sQuery, aSort, aGroup, iOffset, iLimit, callback) {
      var cWhere1, cWhere2, findOptions, oWhere, operMap, reduceWhere, value, _i, _j, _len, _len1, _ref, _ref1;
      if (aFilter == null) {
        aFilter = [];
      }
      if (sQuery == null) {
        sQuery = '';
      }
      if (aSort == null) {
        aSort = [];
      }
      if (aGroup == null) {
        aGroup = [];
      }
      if (iOffset == null) {
        iOffset = 0;
      }
      if (iLimit == null) {
        iLimit = 15;
      }
      findOptions = {};
      oWhere = {};

      /*
      Get order list from aSort
      each element is a object {field, dir}
       */
      findOptions.order = aSort.reduce(function(l, r) {
        var s;
        s = r.field + ' ' + r.dir.toUpperCase();
        if (l === '') {
          l = s;
        } else {
          l += ',' + s;
        }
        return l;
      }, '');
      operMap = {
        eq: '=',
        lt: '<',
        gt: '>',
        gte: '>=',
        lte: '<=',
        ne: '!=',
        bt: 'BETWEEN',
        nbt: 'NOT BETWEEN',
        like: 'LIKE'
      };

      /*
      Get where list from aFilter
      each element is a object {field, cmp, value}
       */
      reduceWhere = aFilter.reduce(function(l, r) {
        var aValues, ret, s, sHolder;
        sHolder = l.holder;
        aValues = l.values;
        s = r.field + ' ' + operMap[r.cmp] + ' ? ';
        aValues.push(r.value);
        if (sHolder === '') {
          sHolder = s;
        } else {
          sHolder += ' AND ' + s;
        }
        ret = {
          holder: sHolder,
          values: aValues
        };
        return ret;
      }, {
        holder: '',
        values: []
      });
      if (reduceWhere.holder !== '' && reduceWhere.values.length > 0) {
        cWhere1 = [reduceWhere.holder];
        _ref = reduceWhere.values;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          value = _ref[_i];
          cWhere1.push(value);
        }
        cWhere2 = [reduceWhere.holder];
        _ref1 = reduceWhere.values;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          value = _ref1[_j];
          cWhere2.push(value);
        }
        findOptions['where'] = cWhere1;
        oWhere = {
          'where': cWhere2
        };
      }
      findOptions = {};
      oWhere = {};
      findOptions.skip = parseInt(iOffset);
      findOptions.limit = parseInt(iLimit);
      async.waterfall([
        (function(_this) {
          return function(cb) {
            ModelClazz.count(oWhere, function(err, return_count) {
              cb(err, return_count);
            });
          };
        })(this), (function(_this) {
          return function(return_count, cb) {
            ModelClazz.all(findOptions, function(error, docs) {
              cb(error, docs, return_count);
            });
          };
        })(this)
      ], function(error, docs, return_count) {
        var sumDoc;
        sumDoc = {};
        callback(error, docs, return_count, sumDoc);
      });
    };

    JugglingCrud.prototype.readOne = function(ModelClazz, id, callback) {
      ModelClazz.find(id, function(error, doc) {
        return callback(error, doc);
      });
    };

    JugglingCrud.prototype.create = function(ModelClazz, value, callback) {
      ModelClazz.create(value, function(error, doc) {
        return callback(error, doc);
      });
    };

    JugglingCrud.prototype.update = function(ModelClazz, id, value, callback) {
      async.waterfall([
        (function(_this) {
          return function(cb) {
            console.log('record id: ', id);
            ModelClazz.find(id, function(error, doc) {
              cb(error, doc);
            });
          };
        })(this), (function(_this) {
          return function(doc, cb) {
            if (doc != null) {
              doc.updateAttributes(value, function(error, model) {
                cb(error, model);
              });
            } else {
              cb("Cound not find record id: " + id, null);
            }
          };
        })(this)
      ], function(error, doc) {
        return callback(error, doc);
      });
    };

    JugglingCrud.prototype["delete"] = function(ModelClazz, id, callback) {
      async.waterfall([
        (function(_this) {
          return function(cb) {
            console.log('record id: ', id);
            ModelClazz.find(id, function(error, doc) {
              cb(error, doc);
            });
          };
        })(this), (function(_this) {
          return function(doc, cb) {
            if (doc != null) {
              doc.destroy(function(error) {
                cb(error, null);
              });
            } else {
              cb("Cound not find record id: " + id, null);
            }
          };
        })(this)
      ], function(error, doc) {
        return callback(error, doc);
      });
    };

    return JugglingCrud;

  })(BaseCrud);

  exports.JugglingCrud = JugglingCrud;

}).call(this);

//# sourceMappingURL=juggling-crud.map
